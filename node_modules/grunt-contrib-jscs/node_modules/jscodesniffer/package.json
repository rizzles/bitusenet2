{
  "name": "jscodesniffer",
  "description": "Tool to ensure that your JavaScript code does not violate the specified coding standard (Idiomatic Style Manifesto or JQuery Core Style Guidelines)",
  "version": "2.1.8",
  "author": {
    "name": "Dmitry Sheiko",
    "email": "me@dsheiko.com"
  },
  "contributors": [],
  "main": "jscs-module.js",
  "homepage": "http://dsheiko.github.io/jscodesniffer/",
  "bin": {
    "jscs": "./jscs"
  },
  "dependencies": {
    "esprima": "~1.0.4"
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-jshint": "~0.4.3",
    "grunt-mocha-cli": "~1.2.1",
    "assert": ">=0.4.9",
    "mocha": ">=1.7.4",
    "should": "*",
    "jsdoc": "*"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/fawek/codepainter/raw/master/LICENSE"
    }
  ],
  "maintainers": [
    {
      "name": "Dmitry Sheiko",
      "email": "me@dsheiko.com",
      "url": "http://dsheiko.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/dsheiko/jscodesniffer.git"
  },
  "bugs": {
    "url": "https://github.com/dsheiko/jscodesniffer/issues"
  },
  "scripts": {
    "test": "grunt test"
  },
  "keywords": [
    "styleguide",
    "formatter"
  ],
  "readme": "JSCodeSniffer v.2.x\r\n==============\r\n[![Build Status](https://travis-ci.org/dsheiko/jscodesniffer.png)](https://travis-ci.org/dsheiko/jscodesniffer)\r\n[![NPM version](https://badge.fury.io/js/jscodesniffer.png)](http://badge.fury.io/js/jscodesniffer)\r\n\r\nJSCodeSniffer is a node.js application that checks JavaScript code style consistency according to a provided coding style, just like phpcs.\r\nOne can define a custom coding style by using described below JSON notation or use one of predefined standards.\r\n\r\n\r\n## Features\r\n* Tool is available as UMD (can be used [with nodejs](#a-use) or as a [RequireJS module](#a-amd))\r\n* Predefined popular coding styles ([jQuery Coding Style Guide](http://contribute.jquery.org/style-guide/js/), [Idiomatic Style Manifesto](https://github.com/rwaldron/idiomatic.js/))\r\n* Reports in the style of [phpcs](https://github.com/squizlabs/PHP_CodeSniffer)\r\n* Solution ready for [Continuous Integration](#a-ci)\r\n    - Provided [Git pre-commit hook script](#a-git)\r\n    - Provided [SVN pre-commit hook script](#a-svn)\r\n    - Provided [Grunt task](#a-grunt)\r\n    - Provided [Jenkins CheckStyle report](#a-ant)\r\n* Custom standard [can be easily configured](#a-standard) by using JSON notation\r\n* Scripts can be associated to a coding style in block comments [using `jscs` tag](#a-env)\r\n* Relaxing options can be provided with [real-time configuration](#a-realtime) (`.jscsrc`) per project\r\n* Thoroughly covered with automated tests: 200+ unit-tests, 70+ integration tests\r\n\r\n## Setup\r\n\r\nJS_CodeSniffer relies on node.js. If you don't have node.js installed, just follow the instructions:\r\nhttps://github.com/joyent/node/wiki/Installing-Node.js-via-package-manager\r\n\r\nMake sure all the required dependencies installed\r\n```bash\r\nnpm i\r\n```\r\nMake sure the binary is executable\r\n```bash\r\nchmod +x jscs\r\n```\r\nYou can also create a symlink to make it globally available\r\n```bash\r\nln -s jscs /usr/local/bin/jscs\r\n```\r\n\r\n## <a name=\"a-use\"></a> Using JSCodeSniffer in the command line\r\n\r\nSimply get detailed report on a target (file or directory) coding style according to jQuery Coding Style Guide\r\n```bash\r\n./jscs source-code.js --standard=Jquery\r\n```\r\nor\r\n```bash\r\nnode jscs.js source-code.js  --standard=Jquery\r\n```\r\nor\r\n```bash\r\n./jscs js/dir1 file1.js js/dir2 file2.js --standard=Jquery\r\n```\r\n\r\n![JS CodeSniffer Full Report Example](https://raw.github.com/dsheiko/jscodesniffer/master/doc/sample1.jpg \"JS CodeSniffer Full Report Example\")\r\n\r\nGet detailed report on the coding style for all *.js/*.json files of the 'lib' folder according to jQuery Coding Style Guide\r\n```bash\r\n./jscs lib --standard=Jquery --report-full\r\n```\r\n\r\nGet summary report\r\n```bash\r\n./jscs lib --report-summary\r\n```\r\n![JS CodeSniffer Summary Report Example](https://raw.github.com/dsheiko/jscodesniffer/master/doc/sample2.jpg \"JS CodeSniffer Summary Report Example\")\r\n\r\nGet XML report (which allows you to parse the output easily and use the results in your own scripts)\r\n```bash\r\n./jscs lib --report=xml\r\n```\r\n\r\nGet Checkstyle report (that is supported by wide range of 3rd party software. E.g. Jenkins via a plugin)\r\n```bash\r\n./jscs lib --report=checkstyle\r\n```\r\n\r\nReport to a file (by default report goes to stdout)\r\n```bash\r\n./jscs lib --report-file=filePath\r\n```\r\n\r\nDisable colors in the report\r\n```bash\r\n./jscs lib --highlight=0\r\n```\r\n\r\nDefine width of report screen\r\n```bash\r\n./jscs lib --reportWidth=84\r\n```\r\n\r\n\r\n## <a name=\"a-amd\"></a> Using JSCodeSniffer as RequireJS (AMD) module\r\n\r\n1. Install the package or download and unpack it into you project folder\r\n\r\n```bash\r\n npm i jscodesniffer\r\n```\r\n\r\n2. Use RequireJS to load required modules\r\n\r\n```javascript\r\nrequire( [ \"<esprima-js-path>/esprima\", \"<pkg-path>/lib/Sniffer\", \"<pkg-path>/lib/Dictionary/en\", \"<pkg-path>/lib/Dictionary\" ], function( esprima, Sniffer, en, Dictionary ) {\r\n  var sniffer = new Sniffer( esprima ),\r\n      dictionary = new Dictionary( en ),\r\n      logger, messages;\r\n\r\n    // Get sniffer report\r\n    logger = sniffer.getTestResults( node.srcCode.value, { standard: \"Jquery\" } ),\r\n    // Translate messages\r\n    messages = dictionary.translateBulk( logger.getMessages(), true );\r\n    // Output report\r\n    console.log( messages );\r\n});\r\n```\r\n\r\n\r\n## <a name=\"a-env\"></a> Environments\r\n\r\nStandard to sniff against can be enforced on the file by following instructions directly in the code\r\n```javascript\r\n/* jscs standard:Jquery */\r\n```\r\nOld form introduced in version 1.x.x is also supported\r\n```javascript\r\n/* @jscs standard:Jquery */\r\n```\r\n\r\n## <a name=\"a-realtime\"></a> Real-Time Configuration\r\n\r\nAdjusting options can be provided as manual standard in `.jscsrc` file placed in the root of your project.\r\nJSCodesniffer will search upward recursively until it finds any. It will extend the specified standard rule-sets\r\nwith the defenitions provided in this real-time configuration file. `.jscsrc` syntax is pretty much the same as standard\r\ndefenition file except it doesn't need to be UMD (just JSON). I you need disable particular rule-sets you can simply\r\nempty rule-set configurations:\r\n\r\n```bash\r\n{\r\n  \"Indentation\": false,\r\n  \"QuoteConventions\": false\r\n}\r\n```\r\n\r\n## <a name=\"a-standard\"></a> Declaring coding style\r\nStandard declaration are located in `standard` directory. You can store there in a file named after your custom standard name\r\nthe rule-sets that you want your code be validated against. To make the defenition available for AMD/RequireJs, the JSON notation is supposed\r\nto be wrapped as a UMD module.\r\n\r\nNOTE: Conventions 'Any ; used as a statement terminator must be at the end of the line' and 'Multi-line Statements is checked'\r\nare tested by JSHint and therefore not provided with sniffs (See [http://contribute.jquery.org/style-guide/js/#linting] for details).\r\n\r\n```javascript\r\n{\r\n  /*\r\n    defines what characters allowed for line indentation\r\n  */\r\n    \"Indentation\": {\r\n      \"allowOnlyTabs\": true,\r\n      \"allowOnlySpaces\": true,\r\n      \"disallowMixed\": true\r\n    },\r\n  /*\r\n    defines if trailing spaces allowed for lines\r\n  */\r\n    \"LineSpacing\": {\r\n      \"allowLineTrailingSpaces\": false\r\n    },\r\n  /*\r\n    defines allowed range for line length\r\n  */\r\n    \"LineLength\": {\r\n      \"allowMaxLength\": 80,\r\n      \"allowMinLength\": 0\r\n    },\r\n  /*\r\n    defines spacing conventions for comma punctuator\r\n    Example:\r\n    // good\r\n    var foo, bar;\r\n    // bad\r\n    var foo , bar;\r\n  */\r\n    \"CommaPunctuatorSpacing\": {\r\n      \"disallowPrecedingSpaces\": false\r\n    },\r\n  /*\r\n    defines spacing conventions for semicolon punctuator\r\n    Example:\r\n    // good\r\n    var foo;\r\n    // bad\r\n    var foo ;\r\n  */\r\n    \"SemicolonPunctuatorSpacing\": {\r\n      \"disallowPrecedingSpaces\": false\r\n    },\r\n\r\n  /*\r\n    defines scoping rules for compound statements\r\n\r\n    Example:\r\n    // good\r\n    if ( true ) {\r\n      var foo = \"bar\";\r\n    }\r\n    // bad\r\n    if ( true ) var foo = \"bar\";\r\n\r\n  */\r\n    \"CompoundStatementConventions\": {\r\n      \"for\": [\r\n        \"IfStatement\",\r\n        \"SwitchStatement\",\r\n        \"WhileStatement\",\r\n        \"DoWhileStatement\",\r\n        \"ForStatement\",\r\n        \"ForInStatement\",\r\n        \"WithStatement\",\r\n        \"TryStatement\"\r\n      ],\r\n      \"requireBraces\": true,\r\n      \"requireMultipleLines\": true\r\n    },\r\n    /*\r\n    defines spacing conventions for unary expressions\r\n\r\n    Example:\r\n    !!100 // good\r\n    !! 100 // bad\r\n    */\r\n    \"UnaryExpressionIdentifierSpacing\": {\r\n      \"allowTrailingWhitespaces\" : 0\r\n    },\r\n    /*\r\n    defines spacing conventions for ternary conditionals\r\n\r\n    Example:\r\n    foo = true ? 1 : 0; // good\r\n    foo = true ?1:0; // bad\r\n    */\r\n    \"TernaryConditionalPunctuatorsSpacing\": {\r\n      \"allowTestTrailingWhitespaces\": 1,\r\n      \"allowConsequentPrecedingWhitespaces\": 1,\r\n      \"allowConsequentTrailingWhitespaces\": 1,\r\n      \"allowAlternatePrecedingWhitespaces\": 1,\r\n       /*\r\n        Optional modifier.\r\n        When undefined the sniffer treats nesting statements the same\r\n            as regular\r\n        When false, no rules applied for nesting statements\r\n        When defined, the corresponding rules go for nesting statements\r\n        foo( a?b:c )\r\n        */\r\n      \"ifNesting\": {\r\n        \"allowTestTrailingWhitespaces\": 0,\r\n        \"allowConsequentPrecedingWhitespaces\": 0,\r\n        \"allowConsequentTrailingWhitespaces\": 0,\r\n        \"allowAlternatePrecedingWhitespaces\": 0\r\n      }\r\n    },\r\n    /*\r\n    defines spacing conventions for empty constructs\r\n    \"for\" qualifier takes an array of tokens compatible with\r\n    Mozilla Parser AST (https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API)\r\n\r\n    Example:\r\n    obj = {}; // good\r\n    obj = {  }; // bad\r\n    */\r\n    \"EmptyConstructsSpacing\": {\r\n      \"for\": [\r\n        \"ObjectExpression\",\r\n        \"ArrayExpression\",\r\n        \"CallExpression\"\r\n      ],\r\n      \"allowWhitespaces\": false\r\n    },\r\n   /*\r\n    defines spacing conventions for object literals\r\n\r\n    Example:\r\n    obj = { prop: 1 }; // good\r\n    obj = { prop:1 };// bad\r\n    */\r\n    \"ObjectLiteralSpacing\": {\r\n      \"allowKeyPrecedingWhitespaces\": 1,\r\n      \"allowKeyTrailingWhitespaces\": 0,\r\n      \"allowValuePrecedingWhitespaces\": 1,\r\n      \"allowValueTrailingWhitespaces\": 1\r\n    },\r\n   /*\r\n    defines spacing conventions for array literals\r\n\r\n    Example:\r\n    arr = [ 1, 2 ]; // good\r\n    arr = [1,2]; // bad\r\n    */\r\n    \"ArrayLiteralSpacing\": {\r\n      \"allowElementPrecedingWhitespaces\": 1,\r\n      \"allowElementTrailingWhitespaces\": 1,\r\n      /*\r\n      Optional modifier.\r\n      \"for\" qualifier takes an array of tokens compatible with\r\n      Mozilla Parser AST (https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API)\r\n      When qualifier \"for\" is missing the exception rules gets applied for any node type\r\n      */\r\n      \"exceptions\": {\r\n        \"singleElement\": {\r\n          \"for\": [ \"Literal\" ],\r\n          \"allowElementPrecedingWhitespaces\": 0,\r\n          \"allowElementTrailingWhitespaces\": 0\r\n        },\r\n        \"firstElement\": {\r\n          \"for\": [ \"Literal\" ],\r\n          \"allowElementPrecedingWhitespaces\": 1\r\n        },\r\n        \"lastElement\": {\r\n          \"for\": [ \"Literal\" ],\r\n          \"allowElementTrailingWhitespaces\": 1\r\n        }\r\n      }\r\n    },\r\n   /*\r\n    defines type of quotes to use across the code-base\r\n\r\n    Example:\r\n    foo = \"text\"; // good\r\n    foo = 'text'; // bad\r\n    */\r\n    \"QuoteConventions\": {\r\n      \"allowDoubleQuotes\": true,\r\n      \"allowSingleQuotes\": false\r\n    },\r\n    /*\r\n    defines naming conventions for variables\r\n    Note: variable of all uppercase (including $_0-9) are considered as constants and ignored by the sniffer\r\n\r\n    Example:\r\n    var camelCase; // good\r\n    var not_camel_case; // bad\r\n    */\r\n    \"VariableNamingConventions\": {\r\n      \"allowCase\": [\"camel\"],\r\n      \"allowRepeating\": true,\r\n      \"allowNumbers\": true\r\n    },\r\n   /*\r\n    defines naming conventions for functions\r\n\r\n    Example:\r\n    var PascalCase; // good\r\n    var not_camel_or_pascal_case; // bad\r\n    */\r\n    \"FunctionNamingConventions\": {\r\n      \"allowCase\": [\"camel\", \"pascal\"],\r\n      \"allowRepeating\": true,\r\n      \"allowNumbers\": true\r\n    },\r\n    /*\r\n    defines naming conventions for new expressions\r\n\r\n    Example:\r\n    obj = new Constructor(); // good\r\n    obj = new constructor(); // bad\r\n    */\r\n    \"NewExpressionCalleeNamingConventions\": {\r\n      \"allowCase\": [ \"pascal\" ],\r\n      \"allowRepeating\": true,\r\n      \"allowNumbers\": true\r\n    },\r\n\r\n   /*\r\n    defines spacing conventions for arguments\r\n\r\n    Example:\r\n    fn( 1, 2 ); // good\r\n    fn(1,2); // bad\r\n    */\r\n    \"ArgumentsSpacing\": {\r\n      \"allowArgPrecedingWhitespaces\": 1,\r\n      \"allowArgTrailingWhitespaces\": 1,\r\n      /*\r\n        Optional modifier.\r\n       \"for\" qualifier takes an array of tokens compatible with\r\n        Mozilla Parser AST (https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API)\r\n        When qualifier \"for\" is missing the exception rules gets applied for any node type\r\n      */\r\n      \"exceptions\": {\r\n        \"singleArg\" : {\r\n          \"for\": [ \"FunctionExpression\", \"ArrayExpression\", \"ObjectExpression\" ],\r\n          \"allowArgPrecedingWhitespaces\": 0,\r\n          \"allowArgTrailingWhitespaces\": 0\r\n        },\r\n        \"firstArg\": {\r\n          \"for\": [ \"FunctionExpression\" ],\r\n          \"allowArgPrecedingWhitespaces\": 0\r\n        },\r\n        \"lastArg\": {\r\n          \"for\": [ \"FunctionExpression\" ],\r\n          \"allowArgTrailingWhitespaces\": 0\r\n        }\r\n      },\r\n      /*\r\n        Optional modifier.\r\n        When undefined the sniffer treats nesting statements the same\r\n            as regular\r\n        When false, no rules applied for nesting statements\r\n        When defined, the corresponding rules go for nesting statements\r\n        foo( bar(1,1) )\r\n        */\r\n      \"ifNesting\": {\r\n        \"allowArgPrecedingWhitespaces\": 0,\r\n        \"allowArgTrailingWhitespaces\": 0\r\n      }\r\n    },\r\n  /*\r\n    defines spacing conventions for parameters\r\n\r\n    Example:\r\n    function fn( foo, bar ){}; // good\r\n    function fn(foo,bar){}; // bad\r\n    */\r\n    \"ParametersSpacing\": {\r\n      \"allowParamPrecedingWhitespaces\": 1,\r\n      \"allowParamTrailingWhitespaces\": 1,\r\n      /*\r\n      Optional modifier.\r\n      When qualifier \"for\" is missing the exception rules gets applied for any node type\r\n      */\r\n      \"exceptions\": {\r\n        \"singleParam\": {\r\n          \"for\": [ \"Literal\" ],\r\n          \"allowElementPrecedingWhitespaces\": 0,\r\n          \"allowElementTrailingWhitespaces\": 0\r\n        },\r\n        \"firstParam\": {\r\n          \"for\": [ \"Literal\" ],\r\n          \"allowElementPrecedingWhitespaces\": 1\r\n        },\r\n        \"lastParam\": {\r\n          \"for\": [ \"Literal\" ],\r\n          \"allowElementTrailingWhitespaces\": 1\r\n        }\r\n      }\r\n    },\r\n    /*\r\n    defines how methods can be placed when a chain of method calls is too long to fit on one line\r\n\r\n    Example:\r\n    // good\r\n    elements\r\n    .addClass( \"foo\" )\r\n    .children();\r\n\r\n    // bad\r\n    elements.addClass( \"foo\" )\r\n    .children();\r\n    */\r\n\r\n    \"ChainedMethodCallsPerLineConventions\": {\r\n      \"requireOnePerLineWhenMultilineCaller\": true\r\n    },\r\n    /*\r\n    defines spacing conventions for chains of method calls\r\n    Example:\r\n    // good\r\n    elements.addClass( \"foo\" )\r\n\r\n    // bad\r\n    elements.  addClass( \"foo\" )\r\n    */\r\n    \"ChainedMethodCallsSpacing\": {\r\n      \"allowPrecedingPropertyWhitespaces\": 0\r\n    },\r\n    /*\r\n    defines spacing conventions for operators (including declarator)\r\n\r\n    Example:\r\n    foo = 1 + 1; // good\r\n    foo = 1+1; // bad\r\n    */\r\n    \"OperatorSpacing\" : {\r\n      \"allowOperatorPrecedingWhitespaces\": 1,\r\n      \"allowOperatorTrailingWhitespaces\": 1\r\n    },\r\n    /*\r\n    defines conventions for variable declarations\r\n\r\n    Example:\r\n    // good\r\n    (function(){\r\n      var foo, bar;\r\n    })();\r\n\r\n    // bad\r\n    (function(){\r\n      var foo;\r\n      var bar;\r\n    })();\r\n    */\r\n    \"VariableDeclarationPerScopeConventions\" : {\r\n      \"disallowMultiplePerBlockScope\": true,\r\n      \"requireInTheBeginning\": true\r\n    },\r\n    /*\r\n    defines conventions for object declarations\r\n\r\n    Example:\r\n    // good\r\n    o = { p1: 1, p2: 2 }\r\n    // good\r\n    o = {\r\n      p1: 1,\r\n      p2: 2\r\n    }\r\n    // bad\r\n    o = {\r\n      p1: 1, p2: 2 }\r\n     */\r\n    \"ObjectLiteralConventions\": {\r\n      \"requireOnePerLineWhenMultiline\": true\r\n    },\r\n    /*\r\n    defines conventions for array declarations\r\n\r\n    Example:\r\n    // good\r\n    arr = [ 1, \"two\" ]\r\n    // good\r\n    arr = [\r\n      1,\r\n      \"two\"\r\n    ]\r\n    // bad\r\n    arr = [\r\n      1, \"two\" ]\r\n    */\r\n    \"ArrayLiteralConventions\": {\r\n      \"requireOnePerLineWhenMultiline\": true\r\n    }\r\n  }\r\n```\r\n\r\n# <a name=\"a-ci\"></a>JSCodeSniffer and Continuous Integration\r\n\r\n## <a name=\"a-ant\"></a>Setting up [Apache Ant](http://ant.apache.org/) build script reporting to [Jenkins](http://jenkins-ci.org) Checkstyle plugin.\r\nNOTE: If you have phpcs-ci ant target, invoke it prior to this one. Jscs will find created by phpcs checkstyle.xml and extend its body instead of overriding the report.\r\n```xml\r\n<target name=\"jscs-ci\"\r\n         description=\"Find coding standard violations using JS_CodeSniffer and print human readable output.\">\r\n  <exec executable=\"jscs\">\r\n   <arg value=\"--standard=Jquery\" />\r\n   <arg value=\"--report=checkstyle\" />\r\n   <arg value=\"--report-file=${basedir}/build/logs/checkstyle.xml\" />\r\n   <arg path=\"${basedir}/src\" />\r\n  </exec>\r\n </target>\r\n```\r\n\r\n## <a name=\"a-grunt\"></a>Setting up [Grunt](http://gruntjs.com/) task\r\n\r\n*Gruntfile.js*\r\n```javascript\r\ngrunt.loadNpmTasks('grunt-contrib-jscs');\r\ngrunt.initConfig({\r\n     // Validate against jQuery coding standard\r\n     jscs: {\r\n        options: {\r\n            \"standard\": \"Jquery\"\r\n        },\r\n        all: [\"js-folder\"]\r\n     }\r\n  });\r\n```\r\n*package.json*\r\n```javascript\r\n\"devDependencies\": {\r\n    //..\r\n    \"grunt-contrib-jscs\": \"*\"\r\n  }\r\n```\r\n\r\n## <a name=\"a-svn\"></a> Using the Subversion pre-commit hook\r\n\r\nA pre-commit hook is a feature available in the Subversion version control system that allows code to be validated before it is committed to the repository.\r\nEdit scripts/jscs-svn-pre-commit and replace JSCS value with your own path to JS CodeSniffer\r\n```bash\r\nJSCS = \"/your-path/jscodesniffer\"\r\n```\r\n\r\nMake a symlink of scripts/jscs-svn-pre-commit in your repository hooks folder. E.g.\r\n```bash\r\nln -s /<full path>/scripts/jscs-svn-pre-commit /repositories/<project>/hooks/pre-commit\r\n```\r\n\r\n## <a name=\"a-git\"></a> Using the git pre-commit hook\r\nMake a symlink of scripts/jscs-git-pre-commit in your repository .git/hooks folder. E.g.\r\n```bash\r\nln -s /<full path>/scripts/jscs-git-pre-commit /<project>/.git/hooks/pre-commit\r\n```\r\n\r\n\r\n## API Notes\r\n\r\nHigh-level interface example (the report in stdout):\r\n```javascript\r\nvar argv = [ \"node\", \"jscs\", \"./source-dir/\", \"--standard=Jquery\", \"--report-full\" ],\r\n\t\tjscodesniffer = require( \"jscodesniffer\" );\r\n\r\njscodesniffer( argv, process.cwd() );\r\n```\r\n\r\nLow-level one example:\r\n```javascript\r\nvar Sniffer = require( \"./lib/Sniffer\" ),\r\n\t\tsniffer = new Sniffer(),\r\n\t\tsrc = \"var a= 1;\",\r\n\t\toptions = {\r\n\t\t\tstandard: \"Jquery\"\r\n\t\t},\r\n\t\tlogger = sniffer.getTestResults( src, options, {} );\r\n\r\nconsole.log(logger.getMessages());\r\n\r\n/*\r\n  [ { sniff: 'OperatorSpacing',\r\n    errorCode: 'OperatorPrecedingWhitespaces',\r\n    range: [ 5, 5 ],\r\n    loc: {  start: { line: 1, column: 5 }, end: { line: 1, column: 5 }  },\r\n    payload:\r\n     { actual: 0,\r\n       expected: 1,\r\n       excerpt: '',\r\n       trace: '..a=..',\r\n       where: '<' } } ]\r\n\r\n*/\r\n```\r\n\r\n## Developing a sniff\r\n\r\nLet's consider a sniff, which validates the number of spaces preceding parameter list in a function declaration.\r\nFirst of all, we need to apply the defined rules to function declarations only. Syntax Tree gives us\r\nprecise information about any function declaration in the code. As the sniff will rely on Syntax Tree we\r\nplace the new module to /Lib/Sniff/SyntaxTree and name it according to the defined\r\nrule-set `FunctionDeclarationParameterListSpacing` (has to be also presented in `SyntaxAnalizer`).\r\n\r\nEvery sniff module has method `validateRule`. There we simply enlist the option validators:\r\n```\r\nutils.validateRule( rule, \"allowPrecedingWhitespaces\", \"number\", true );\r\n```\r\n\r\nMethod `run` performs the sniffing job. There we lop off all the inappropriate nodes (`node.type === \"FunctionDeclaration\"`).\r\nNow we have to determine what the node parts correspond to the rule. In this case we need\r\nfunction identifier (`node.id`) and the following token representing opening parenthesis. Unfortunately the Syntax Tree\r\ndoesn't contain any information about such tokens as grouping parentheses. However we can ask TokenIterator for help.\r\nLet's get the token corresponding to the function identifier:\r\n```\r\ntokenIt = tokenIterator.findByLeftPos( node.id.range[ 0 ] );\r\n```\r\nNow we can simply request the token following this one as `tokenIt.get( 1 )` (and preceding as `tokenIt.get( -1 )`.\r\nSo the spaces of our interest are expected between those two tokens. We can make sure we point to the right code\r\nfragment like that:\r\n\r\n```\r\nsourceCode.extract( node.id.range[ 1 ], tokenIt.get( 1 ).range[ 0 ] ).print();\r\n```\r\n\r\nto make the real check, we use the following mixin:\r\n```\r\nmixin.sniffExcerpt( node.id, tokenIt.get( 1 ),\r\n  rule.allowPrecedingWhitespaces, \"FunctionDeclarationParamListPrecedingSpacing\", \"<\" );\r\n```\r\n\r\n\r\n[![githalytics.com alpha](https://cruel-carlota.pagodabox.com/ec7ee35f81b13e41097453e9da3106cb \"githalytics.com\")](http://githalytics.com/dsheiko/jscodesniffer)",
  "readmeFilename": "README.md",
  "_id": "jscodesniffer@2.1.8",
  "dist": {
    "shasum": "3728c5b9be96279ec69b7ad939de975096698c93"
  },
  "_from": "jscodesniffer@>=2.0.3",
  "_resolved": "https://registry.npmjs.org/jscodesniffer/-/jscodesniffer-2.1.8.tgz"
}
